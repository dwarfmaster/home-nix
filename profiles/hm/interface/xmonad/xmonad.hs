import XMonad hiding ((|||))
import XMonad.Layout hiding ((|||))
import XMonad.Operations
import qualified XMonad.StackSet as W

import XMonad.Hooks.DynamicLog
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.ManageHelpers
import XMonad.Hooks.EwmhDesktops

import XMonad.Util.Run (runProcessWithInput, safeSpawn)
import XMonad.Util.EZConfig (additionalKeys)
import XMonad.Util.NamedWindows (getName)
import qualified XMonad.Util.ExtensibleState as XS

import XMonad.Layout.BinarySpacePartition
import XMonad.Layout.LayoutCombinators
import XMonad.Layout.Renamed
import XMonad.Layout.Spacing
-- import XMonad.Actions.Submap
import XMonad.Actions.UpdatePointer
import XMonad.Actions.CycleWS
import XMonad.Actions.WithAll (killAll)
import qualified XMonad.Actions.DynamicWorkspaces as DW

import System.IO
import System.Exit
import qualified Data.Map as M
import Data.Char (isSpace)
import Data.Maybe (isJust, isNothing)
import Data.List (find, intersperse)
import Control.Monad (forM_, foldM)
import Graphics.X11.ExtraTypes.XF86

import XMonad.Prompt.ConfirmPrompt

-- File generated by home-manager, with relevant information
import qualified Nix

modkey = mod4Mask

mlayout = tiled ||| Full
 where tiled   = renamed [Replace "Tiled"] inter
       inter   = spacingRaw False (mkBord 0) False (mkBord 10) True
               $ emptyBSP -- Use binary space partitioning
       mkBord  = \n -> Border n n n n

data Workspaces = Workspaces String [String]
instance ExtensionClass Workspaces where
  initialValue = Workspaces "personal" ["settings"]
views = ["l4", "l3", "l2", "l1", "l0", "r0", "r1", "r2", "r3", "r4"]
view_keys = [xK_q, xK_s, xK_d, xK_f, xK_g, xK_h, xK_j, xK_k, xK_l, xK_m]

currentWorkspace :: X String
currentWorkspace = do
  Workspaces current _ <- XS.get
  return current
jumpToView :: String -> X ()
jumpToView view = do
  ws <- currentWorkspace
  DW.addWorkspace $ ws ++ "^" ++ view
sendToView :: String -> X ()
sendToView view = do
  ws <- currentWorkspace
  windows $ W.shift $ ws ++ "^" ++ view

runRofi :: String -> [String] -> X (Maybe String)
runRofi prompt possibilities = do
  let input = possibilities >>= (++ "\n")
  let trimRev = reverse . dropWhile isSpace
  let trim = trimRev . trimRev
  output <- trim <$> runProcessWithInput Nix.rofi ["-dmenu", "-p"] input
  return $ if output == ""
    then Nothing
    else Just output

splitWorkName :: String -> (String,String)
splitWorkName name = let (ws,view) = span (/='^') name in (ws, safeTl view)
  where safeTl [] = []
        safeTl (_ : xs) = xs

currentWorkView :: X (String,String)
currentWorkView =
  splitWorkName <$> (withWindowSet $ pure . W.currentTag)

listWorkspaces :: X [String]
listWorkspaces = do
  Workspaces current others <- XS.get
  return $ current : others
askWorkspace :: String -> Bool -> X (Maybe String)
askWorkspace query allowNew = do
  workspaces <- listWorkspaces
  workspace <- runRofi query workspaces
  case workspace of
    Nothing -> return Nothing
    Just workspace ->
      if (not allowNew) && (isNothing $ find (== workspace) workspaces)
        then return Nothing
        else return (Just workspace)

focusWorkView :: String -> String -> X ()
focusWorkView workspace view = do
  XS.put =<< Workspaces workspace . filter (/= workspace) <$> listWorkspaces
  jumpToView view

focusWorkspace :: Bool -> X ()
focusWorkspace create = do
  workspace <- askWorkspace "Workspace" create
  case workspace of
    Nothing -> return ()
    Just workspace -> do
      (_,current) <- currentWorkView
      focusWorkView workspace current

sendToWorkspace :: X ()
sendToWorkspace = do
  workspace <- askWorkspace "Send to" False
  case workspace of
    Nothing -> return ()
    Just workspace -> do
      (_,current) <- currentWorkView
      windows $ W.shift $ workspace ++ "^" ++ current

deleteWorkspace :: X ()
deleteWorkspace = do
  workspaces <- listWorkspaces
  workspace <- askWorkspace "Delete" False
  case (workspaces,workspace) of
    (_, Nothing) -> return ()
    ([_], _) -> return ()
    (_, Just workspace) -> do
      (current_ws,current_view) <- currentWorkView
      prev <-
        if (current_ws == workspace)
          then return $ head $ filter (/= workspace) workspaces
          else return current_ws
      nbWins <- foldM 
        (\count view -> do
          focusWorkView workspace view
          wins <- withWindowSet (pure . length . W.integrate' . W.stack . W.workspace . W.current)
          return $ count + wins)
        0
        views
      focusWorkView prev current_view
      confirmPrompt def ("Delete workspace " ++ workspace ++ " with " ++ show nbWins ++ " windows ?") $ do
        forM_ views $ \view -> do
          focusWorkView workspace view
          killAll
          DW.removeWorkspace
        focusWorkView prev current_view
        XS.put =<< Workspaces prev . filter (\ws -> ws /= workspace && ws /= prev) <$> listWorkspaces
        
-- onscreen list all view that are displayed on other monitors than the focused one
updateEww :: String -> String -> [String] -> X ()
updateEww workspace view onscreen =
  let status = fmap prepareView onscreen in
  let viewing = intersperse "," (render <$> status) >>= id in
  safeSpawn Nix.eww 
            [ "update"
            , "xmonad={\"workspace\": \"" 
              ++ workspace 
              ++ "\", \"view\": \"" 
              ++ view 
              ++ "\"}" 
            ]
  -- >> safeSpawn Nix.eww
  --              [ "update"
  --              , "xmonad-onscreen={"
  --                ++ viewing
  --                ++ "}"
  --              ]
  where
    prepareView view =
      if isJust (find (== view) onscreen)
        then (view, True)
        else (view, False)
    render (view, active) = 
      "\"" ++ view ++ "\": " ++ (if active then "true" else "false")

updateEwwHook :: X ()
updateEwwHook = do
  onscreen <- (fmap $ snd . splitWorkName . W.tag . W.workspace) 
           <$> withWindowSet (\ws -> pure $ W.current ws : W.visible ws)
  (workspace,view) <- currentWorkView
  updateEww workspace view onscreen


keybinds = M.fromList $
         [ ((modkey .|. shiftMask, xK_n),  io (exitWith ExitSuccess))
         -- Client focus control
         , ((modkey, xK_x),                         kill)
         , ((modkey, xK_Tab),                       windows W.focusDown)
         , ((modkey, xK_twosuperior),               windows W.focusUp)
         , ((modkey .|. shiftMask, xK_Return),      windows W.swapMaster)
         -- Screen focus control
         , ((modkey, xK_comma),                   prevScreen)
         , ((modkey, xK_semicolon),               nextScreen)
         , ((modkey .|. shiftMask, xK_comma),     shiftPrevScreen)
         , ((modkey .|. shiftMask, xK_semicolon), shiftNextScreen)
         , ((modkey .|. shiftMask, xK_o),         shiftNextScreen >> nextScreen)
         -- Layout control
         , ((modkey, xK_a), sendMessage $ JumpToLayout "Full")
         , ((modkey, xK_z), sendMessage $ JumpToLayout "Tiled")
         -- Workspaces creations
         , ((modkey, xK_space), focusWorkspace False)
         , ((modkey .|. shiftMask, xK_space), sendToWorkspace)
         , ((modkey, xK_c), focusWorkspace True)
         , ((modkey .|. shiftMask, xK_c), deleteWorkspace)
         ] ++ (viewKeys =<< zip view_keys views)
 where viewKeys (k,view) =
         [ ((modkey, k),               jumpToView view)
         , ((modkey .|. shiftMask, k), sendToView view)]

myManageHook = composeAll
    [ title =? "Property Browser â€” SolveSpace" --> doFloat
    , className =? "popup" --> doRectFloat (W.RationalRect 0.1 0.1 0.8 0.8)
    --, role =? "GtkFileChooserDialog" --> doFloat -- role is not defined
    ]

mconfig = ewmh $ docks $ def
        { borderWidth        = 2
        , terminal           = Nix.terminal
        , normalBorderColor  = Nix.normalColor
        , focusedBorderColor = Nix.focusedColor
        , modMask            = modkey
        , layoutHook         = avoidStruts $ mlayout
        , workspaces         = ("personal^" ++) <$> views
        , keys               = const keybinds
        , manageHook         = manageDocks <+> myManageHook <+> manageHook def
        , logHook            = updatePointer (0.5,0.5) (0,0) >> updateEwwHook
        , startupHook        = jumpToView "l1"
        , handleEventHook    = handleEventHook def <+> fullscreenEventHook
        }

main = safeSpawn Nix.eww
         [ "open-many"
         , "statusbar-left"
         , "statusbar-center"
         , "statusbar-right"
         ]
       >> xmonad mconfig
