import XMonad hiding ((|||))
import XMonad.Layout hiding ((|||))
import XMonad.Operations
import qualified XMonad.StackSet as W

import XMonad.Hooks.DynamicLog
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.ManageHelpers
import XMonad.Hooks.EwmhDesktops
import XMonad.Hooks.Rescreen (addAfterRescreenHook)
import XMonad.Hooks.RefocusLast (isFloat)

import XMonad.Util.Run (runProcessWithInput, safeSpawn)
import XMonad.Util.EZConfig (additionalKeys)
import XMonad.Util.NamedWindows (getName)
import qualified XMonad.Util.ExtensibleState as XS

import XMonad.Layout.BinarySpacePartition
import XMonad.Layout.LayoutCombinators
import XMonad.Layout.Renamed
import XMonad.Layout.Spacing
-- import XMonad.Actions.Submap
import XMonad.Actions.UpdatePointer
import XMonad.Actions.CycleWS
import XMonad.Actions.WithAll (killAll)
import qualified XMonad.Actions.DynamicWorkspaces as DW

import System.IO
import System.Exit
import qualified Data.Map as M
import Data.Char (isSpace)
import Data.Maybe (isJust, isNothing)
import Data.List (find, intersperse)
import Control.Monad (forM_, foldM, join)
import Control.Arrow ((&&&))
import Graphics.X11.ExtraTypes.XF86

import XMonad.Prompt.ConfirmPrompt

-- File generated by home-manager, with relevant information
import qualified Nix

modkey = mod4Mask

mlayout = tiled ||| Full
 where tiled   = renamed [Replace "Tiled"] inter
       inter   = spacingRaw False (mkBord 0) False (mkBord 10) True emptyBSP -- Use binary space partitioning
       mkBord n = Border n n n n

data Workspaces = Workspaces String [String]
instance ExtensionClass Workspaces where
  initialValue = Workspaces "personal" ["settings"]
views = ["l4", "l3", "l2", "l1", "l0", "r0", "r1", "r2", "r3", "r4"]
viewsWs = filter (uncurry (&&) . ((/= "l0") &&& (/= "r0"))) views
viewKeys = [xK_q, xK_s, xK_d, xK_f, xK_g, xK_h, xK_j, xK_k, xK_l, xK_m]

workspaceName :: String -> String -> String
workspaceName _ "l0" = "l0"
workspaceName _ "r0" = "r0"
workspaceName ws view = ws ++ "^" ++ view

currentWorkspace :: X String
currentWorkspace = do
  Workspaces current _ <- XS.get
  return current
jumpToView :: String -> X ()
jumpToView view = do
  ws <- currentWorkspace
  DW.addWorkspace $ workspaceName ws view
sendToView :: String -> X ()
sendToView view = do
  ws <- currentWorkspace
  windows $ W.shift $ workspaceName ws view

runRofi :: String -> [String] -> X (Maybe String)
runRofi prompt possibilities = do
  let input = possibilities >>= (++ "\n")
  let trimRev = reverse . dropWhile isSpace
  let trim = trimRev . trimRev
  output <- trim <$> runProcessWithInput Nix.rofi ["-dmenu", "-p"] input
  return $ if output == ""
    then Nothing
    else Just output

splitWorkName :: String -> (Maybe String,String)
splitWorkName name = 
  let (ws,view) = span (/='^') name in 
  case view of
  "" -> (Nothing, ws)
  _ : vw -> (Just ws, vw)

currentWorkView :: X (String,String)
currentWorkView = do
  (ws,view) <- splitWorkName <$> withWindowSet (pure . W.currentTag)
  case ws of
    Nothing -> (,view) <$> currentWorkspace
    Just workspace -> pure (workspace,view)


listWorkspaces :: X [String]
listWorkspaces = do
  Workspaces current others <- XS.get
  return $ current : others
askWorkspace :: String -> Bool -> X (Maybe String)
askWorkspace query allowNew = do
  workspaces <- listWorkspaces
  workspace <- runRofi query workspaces
  case workspace of
    Nothing -> return Nothing
    Just workspace ->
      if not allowNew && isNothing (find (== workspace) workspaces)
        then return Nothing
        else return (Just workspace)

focusWorkView :: String -> String -> X ()
focusWorkView workspace view = do
  XS.put . Workspaces workspace . filter (/= workspace) =<< listWorkspaces
  jumpToView view

focusWorkspaceOnAllScreens :: String -> X ()
focusWorkspaceOnAllScreens workspace = do
  (_,current_view) <- 
    withWindowSet (pure . splitWorkName . W.tag . W.workspace . W.current)
  screens <- withWindowSet (\ws -> pure $ W.current ws : W.visible ws)
  XS.put . Workspaces workspace . filter (/= workspace) =<< listWorkspaces
  forM_ screens $ \screen -> do
    let (_,sview) = splitWorkName $ W.tag $ W.workspace screen
    windows (W.view $ W.tag $ W.workspace screen)
    jumpToView sview
  windows (W.view $ workspaceName workspace current_view)

focusWorkspace :: Bool -> X ()
focusWorkspace create = do
  workspace <- askWorkspace "Workspace" create
  forM_ workspace focusWorkspaceOnAllScreens

sendToWorkspace :: X ()
sendToWorkspace = do
  workspace <- askWorkspace "Send to" False
  case workspace of
    Nothing -> return ()
    Just workspace -> do
      (_,current) <- currentWorkView
      windows $ W.shift $ workspaceName workspace current

deleteWorkspace :: X ()
deleteWorkspace = do
  workspaces <- listWorkspaces
  workspace <- askWorkspace "Delete" False
  case (workspaces,workspace) of
    (_, Nothing) -> return ()
    ([_], _) -> return ()
    (_, Just workspace) -> do
      (current_ws,current_view) <- currentWorkView
      prev <-
        if current_ws == workspace
          then return $ head $ filter (/= workspace) workspaces
          else return current_ws
      nbWins <- foldM 
        (\count view -> do
          focusWorkView workspace view
          wins <- withWindowSet (pure . length . W.integrate' . W.stack . W.workspace . W.current)
          return $ count + wins)
        0
        viewsWs
      focusWorkView prev current_view
      confirmPrompt def ("Delete workspace " ++ workspace ++ " with " ++ show nbWins ++ " windows ?") $ do
        forM_ viewsWs $ \view -> do
          focusWorkView workspace view
          killAll
          DW.removeWorkspace
        focusWorkView prev current_view
        XS.put . Workspaces prev . filter (\ws -> ws /= workspace && ws /= prev) =<< listWorkspaces
        
-- onscreen list all view that are displayed on other monitors than the focused one
updateEww :: String -> String -> [String] -> X ()
updateEww workspace view onscreen =
  let status = fmap prepareView onscreen in
  let viewing = join $ intersperse "," (render <$> status) in
  safeSpawn Nix.eww 
            [ "update"
            , "xmonad={\"workspace\": \"" 
              ++ workspace 
              ++ "\", \"view\": \"" 
              ++ view 
              ++ "\"}" 
            ]
  where
    prepareView view =
      if isJust (find (== view) onscreen)
        then (view, True)
        else (view, False)
    render (view, active) = 
      "\"" ++ view ++ "\": " ++ (if active then "true" else "false")

updateEwwHook :: X ()
updateEwwHook = do
  onscreen <- fmap (snd . splitWorkName . W.tag . W.workspace) 
           <$> withWindowSet (\ws -> pure $ W.current ws : W.visible ws)
  (workspace,view) <- currentWorkView
  updateEww workspace view onscreen

rescreenHook :: X ()
rescreenHook = do
  screens <- withWindowSet (\ws -> pure $ W.current ws : W.visible ws)
  let used = snd . splitWorkName . W.tag . W.workspace <$> screens
  forM_ screens $ \screen -> do
    let (swork,sview) = splitWorkName $ W.tag $ W.workspace screen
    Workspaces current _ <- XS.get
    if swork == Just current
      then return ()
      else do
        let nview = head $ filter (\view -> isNothing $ find (== view) used) views
        windows (W.view $ W.tag $ W.workspace screen)
        jumpToView nview

keybinds = M.fromList $
         [ ((modkey .|. shiftMask, xK_n),  io exitSuccess)
         -- Client focus control
         , ((modkey, xK_x),                         kill)
         , ((modkey, xK_Tab),                       windows W.focusDown)
         , ((modkey, xK_twosuperior),               windows W.focusUp)
         , ((modkey .|. shiftMask, xK_Return),      windows W.swapMaster)
         -- Screen focus control
         , ((modkey, xK_comma),                   prevScreen)
         , ((modkey, xK_semicolon),               nextScreen)
         , ((modkey .|. shiftMask, xK_comma),     shiftPrevScreen)
         , ((modkey .|. shiftMask, xK_semicolon), shiftNextScreen)
         , ((modkey .|. shiftMask, xK_o),         shiftNextScreen >> nextScreen)
         -- Layout control
         , ((modkey, xK_a), sendMessage $ JumpToLayout "Full")
         , ((modkey, xK_z), sendMessage $ JumpToLayout "Tiled")
         -- Workspaces creations
         , ((modkey, xK_space), focusWorkspace False)
         , ((modkey .|. shiftMask, xK_space), sendToWorkspace)
         , ((modkey, xK_c), focusWorkspace True)
         , ((modkey .|. shiftMask, xK_c), deleteWorkspace)
         ] ++ (mkViewKeys =<< zip viewKeys views)
 where mkViewKeys (k,view) =
         [ ((modkey, k),               jumpToView view)
         , ((modkey .|. shiftMask, k), sendToView view)]

myManageHook = composeAll
    [ title =? "Property Browser â€” SolveSpace" --> doFloat
    , className =? "popup" --> doRectFloat (W.RationalRect 0.1 0.1 0.8 0.8)
    , isFloat --> doCenterFloat
    ]

mconfig = addAfterRescreenHook rescreenHook . ewmh . ewmhFullscreen . docks $ def
        { borderWidth        = 2
        , terminal           = Nix.terminal
        , normalBorderColor  = Nix.normalColor
        , focusedBorderColor = Nix.focusedColor
        , modMask            = modkey
        , layoutHook         = avoidStruts mlayout
        , workspaces         = workspaceName "personal" <$> views
        , keys               = const keybinds
        , manageHook         = manageDocks <+> myManageHook <+> manageHook def
        , logHook            = updatePointer (0.5,0.5) (0,0) >> updateEwwHook
        , startupHook        = jumpToView "l1"
        , handleEventHook    = handleEventHook def
        }

main = safeSpawn Nix.eww
         [ "open-many"
         , "statusbar-left"
         , "statusbar-center"
         , "statusbar-right"
         ]
       >> xmonad mconfig
