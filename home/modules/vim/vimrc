

"  __  __ _          
" |  \/  (_)___  ___ 
" | |\/| | / __|/ __|
" | |  | | \__ \ (__ 
" |_|  |_|_|___/\___|
"                    
set tabstop=4 shiftwidth=4 expandtab
set autoindent
set mouse=a                             " Enable mouse
set exrc                                " Allow project local .vimrc files
set modeline                            " Read vim commands integrated in files
set secure                              " Restrict commands in project-local vimrc
set encoding=utf-8                      " Default text encoding
set cursorline                          " Highlight the current line
set noshowmode                          " Don't show the current mode, already show by lightline
set ttyfast                             " Make scrolling smoother
set backspace=indent,eol,start          " What can be remove by backspace
set relativenumber                      " Show line number relatively to current
set number                              " Show absolute line number
set undofile                            " Create a .un~ file saving undos accross openings
set listchars+=nbsp:~,tab:>.            " Show unbreakable spaces in list mode
set completeopt=longest,menuone,preview " Completing window option
set guicursor=                          " Disable cursor change in insert mode
set hidden                              " Can open new buffer while the current one is not saved
colorscheme base16-woodland             " Set the colorscheme, make the background option useless
let mapleader=' '                       " Leader key is space
let maplocalleader=','                  " Local leader is ,


"  ____                      _     
" / ___|  ___  __ _ _ __ ___| |__  
" \___ \ / _ \/ _` | '__/ __| '_ \ 
"  ___) |  __/ (_| | | | (__| | | |
" |____/ \___|\__,_|_|  \___|_| |_|
"                                  
" Use perl-like regex when searching
noremap  / /\v
vnoremap / /\v
set hlsearch   " Highlight search results
set incsearch  " Start searching while typing
set ignorecase " Ignore case ...
set smartcase  " ... unless there is at least one maj
set gdefault   " :%s/// -> :%s///g


"  _                        _ _                 
" | |    ___  _ __   __ _  | (_)_ __   ___  ___ 
" | |   / _ \| '_ \ / _` | | | | '_ \ / _ \/ __|
" | |__| (_) | | | | (_| | | | | | | |  __/\__ \
" |_____\___/|_| |_|\__, | |_|_|_| |_|\___||___/
"                   |___/                       
set wrap          " Wrap too long lines
set linebreak     " Don't wrap lines in the middle of a word
set showbreak=+++ " Prefix long line return with


"  _____ _ _      _                         
" |  ___(_) | ___| |_ _   _ _ __   ___  ___ 
" | |_  | | |/ _ \ __| | | | '_ \ / _ \/ __|
" |  _| | | |  __/ |_| |_| | |_) |  __/\__ \
" |_|   |_|_|\___|\__|\__, | .__/ \___||___/
"                     |___/|_|              
" Prevent polyglot from handling files it shouldn't
let g:polyglot_disabled = [ 'markdown' ]
" Arduino files
au BufNewFile,BufRead *.pde setfiletype cpp
au BufNewFile,BufRead *.ino setfiletype cpp

" Markdown files -> pandoc
" TODO doesn't work
au BufNewFile,BufRead,BufFilePre *.md, *.markdown setfiletype=pandoc

" Coq files
" function InitCoqfiles()
"     call coquille#Commands()
"     execute ":UpdateRemotePlugins"
"     call coquille#FNMapping()
" endfunction
" au FileType coq call InitCoqfiles()

" Prevent runtime/filetype.vim to run on coq files
" au BufNewFile,BufRead *.v autocmd! filetypedetect
" au FileType coq let w:coquille_running='false'


"  ____              _             
" / ___| _   _ _ __ | |_ __ ___  __
" \___ \| | | | '_ \| __/ _` \ \/ /
"  ___) | |_| | | | | || (_| |>  < 
" |____/ \__, |_| |_|\__\__,_/_/\_\
"        |___/                     
setlocal spell spelllang=fr,en " Syntax check
set nospell                    " Disabled by default


"  ____             ____ _ _       _                         _ 
" / ___| _   _ ___ / ___| (_)_ __ | |__   ___   __ _ _ __ __| |
" \___ \| | | / __| |   | | | '_ \| '_ \ / _ \ / _` | '__/ _` |
"  ___) | |_| \__ \ |___| | | |_) | |_) | (_) | (_| | | | (_| |
" |____/ \__, |___/\____|_|_| .__/|_.__/ \___/ \__,_|_|  \__,_|
"        |___/              |_|                                
vmap <C-y> :!xclip -f <CR>
map  <C-p> :r!xclip -o<CR>


"  ____  _             _           
" |  _ \| |_   _  __ _(_)_ __  ___ 
" | |_) | | | | |/ _` | | '_ \/ __|
" |  __/| | |_| | (_| | | | | \__ \
" |_|   |_|\__,_|\__, |_|_| |_|___/
"                |___/             
               

"  _    _      _   _   _ _          
" | |  (_)__ _| |_| |_| (_)_ _  ___ 
" | |__| / _` | ' \  _| | | ' \/ -_)
" |____|_\__, |_||_\__|_|_|_||_\___|
"        |___/                      
" TODO find a way to make base16_* schemes work
let g:lightline = {
    \ 'colorscheme': 'solarized',
    \ }


"  ___ _______ 
" | __|_  / __|
" | _| / /| _| 
" |_| /___|_|  
"              
" See https://github.com/junegunn/fzf.vim for all available actions
" Find git-ed files in repo
nmap <Leader>f :GFiles<CR>
" Find files in repo
nmap <Leader>F :Files<CR>
" Find open buffer
nmap <Leader>b :Buffers<CR>
" Find files in the history of files
nmap <Leader>h :History<CR>
" Find a tag in the current buffer
nmap <Leader>t :BTags<CR>
" Find a tag in the repo (needs a tag file)
nmap <Leader>T :Tags<CR>
" Find a line in the current buffer
nmap <Leader>l :BLines<CR>
" Find a line in any open buffer
nmap <Leader>L :Lines<CR>
" Find a marked line
nmap <Leader>m :Marks<CR>
" COC diagnostics
nmap <Leader>d :call GetFzfDiags()<CR>


"   ___ ___   ___ 
"  / __/ _ \ / __|
" | (_| (_) | (__ 
"  \___\___/ \___|
"                 
set updatetime=300 " The default is too long for diagnostic messages
set shortmess+=c   " Don't give ins-completion messages
set signcolumn=yes " Always display the sign column

" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" Use `[c` and `]c` to navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight symbol under cursor on CursorHold
autocmd CursorHold * silent call CocActionAsync('highlight')

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)

" Remap for format selected region
xmap <leader>l  <Plug>(coc-format-selected)
nmap <leader>l  <Plug>(coc-format-selected)

augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
xmap <leader>a  <Plug>(coc-codeaction-selected)
nmap <leader>a  <Plug>(coc-codeaction-selected)

" Remap for do codeAction of current line
nmap <leader>ac  <Plug>(coc-codeaction)
" Fix autofix problem of current line
nmap <leader>qf  <Plug>(coc-fix-current)

" Use <tab> for select selections ranges, needs server support, like: coc-tsserver, coc-python
nmap <silent> <TAB> <Plug>(coc-range-select)
xmap <silent> <TAB> <Plug>(coc-range-select)
xmap <silent> <S-TAB> <Plug>(coc-range-select-backword)

" Use `:Format` to format current buffer
command! -nargs=0 Format :call CocAction('format')

" Use `:Fold` to fold current buffer
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" use `:OR` for organize import of current buffer
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" Display COC diagnostics using FZF
" Taken from https://gist.github.com/RobertBuhren/02e05506255c667c0038ce74ee1cef96
function! s:format_coc_diagnostic(item) abort
  return (has_key(a:item,'file')  ? bufname(a:item.file) : '')
        \ . '|' . (a:item.lnum  ? a:item.lnum : '')
        \ . (a:item.col ? ' col ' . a:item.col : '')
        \ . '| ' . a:item.severity
        \ . ': ' . a:item.message 
endfunction

function! s:get_current_diagnostics() abort
  " Remove entries not belonging to the current file.
  let l:diags = filter(copy(CocAction('diagnosticList')), {key, val -> val.file ==# expand('%:p')})
  return map(l:diags, 's:format_coc_diagnostic(v:val)')
endfunction

function! s:format_qf_diags(item) abort
  let l:parsed = s:parse_error(a:item)
  return {'bufnr' : bufnr(l:parsed['bufnr']), 'lnum' : l:parsed['linenr'], 'col': l:parsed['colnr'], 'text' : l:parsed['text']}
endfunction

function! s:build_quickfix_list(lines)
  call setqflist(map(a:lines, 's:format_qf_diags(v:val)'),'r', "Diagnostics")
endfunc

let s:TYPE = {'dict': type({}), 'funcref': type(function('call')), 'string': type(''), 'list': type([])}

let s:default_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

function! s:action_for(key, ...)
  let default = a:0 ? a:1 : ''
  if a:key == 'ctrl-q'
    let l:Cmd = function('s:build_quickfix_list')
  else
    let l:Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, default)
  endif
  return l:Cmd
endfunction

function! GetFzfDiags() abort
  let l:diags = CocAction('diagnosticList')
  if !empty(l:diags)
    let expect_keys = join(keys(get(g:, 'fzf_action', s:default_action)), ',')
    let l:opts = {
          \ 'source': s:get_current_diagnostics(),
          \ 'sink*': function('s:error_handler'),
          \ 'options': ['--multi','--expect=ctrl-q,'.expect_keys,'--ansi', '--prompt=Coc Diagnostics> '],
          \ }
    call fzf#run(fzf#wrap(l:opts))
    call s:syntax()
  endif
endfunction

function! s:syntax() abort
  if has('syntax') && exists('g:syntax_on')
    syntax match FzfQuickFixFileName '^[^|]*' nextgroup=FzfQuickFixSeparator
    syntax match FzfQuickFixSeparator '|' nextgroup=FzfQuickFixLineNumber contained
    syntax match FzfQuickFixLineNumber '[^|]*' contained contains=FzfQuickFixError
    syntax match FzfQuickFixError 'error' contained

    highlight default link FzfQuickFixFileName Directory
    highlight default link FzfQuickFixLineNumber LineNr
    highlight default link FzfQuickFixError Error
  endif
endfunction

function! s:error_handler(err) abort
   
  let l:Cmd = s:action_for(a:err[0])

  if !empty(l:Cmd) && type(l:Cmd) == s:TYPE.string && stridx('edit', l:Cmd) < 0
    execute 'silent' l:Cmd
  elseif !empty(l:Cmd) && type(l:Cmd) == s:TYPE.funcref
    call l:Cmd(a:err[1:])
    return
  endif
  let l:parsed = s:parse_error(a:err[1:])
  execute 'buffer' bufnr(l:parsed["bufnr"])
  mark '
  call cursor(l:parsed["linenr"], l:parsed["colnr"])
  normal! zvzz

endfunction

function! s:parse_error(err) abort
  let l:match = matchlist(a:err, '\v^([^|]*)\|(\d+)?%(\scol\s(\d+))?.*\|(.*)')[1:4]
  if empty(l:match) || empty(l:match[0])
    return
  endif

  if empty(l:match[1]) && (bufnr(l:match[0]) == bufnr('%'))
    return
  endif

  let l:line_number = empty(l:match[1]) ? 1 : str2nr(l:match[1])
  let l:col_number = empty(l:match[2]) ? 1 : str2nr(l:match[2])
  let l:error_msg = l:match[3]

  return ({'bufnr' : l:match[0],'linenr' : l:line_number, 'colnr':l:col_number, 'text': l:error_msg})
endfunction


" __   ___             _ _   _ 
" \ \ / (_)_ ____ __ _(_) |_(_)
"  \ V /| | '  \ V  V / | / / |
"   \_/ |_|_|_|_\_/\_/|_|_\_\_|
"                              
" Use vim-pandoc with some bindings instead of vimwiki
nmap <return> ,gl
nmap <backspace> ,gb
nmap <leader>ww :e /home/luc/vimwiki/index.pd<return>:cd %:p:h<return>

"  ___              _         
" | _ \__ _ _ _  __| |___  __ 
" |  _/ _` | ' \/ _` / _ \/ _|
" |_| \__,_|_||_\__,_\___/\__|
"                             
" TODO fix E20... error on md files
let g:pandoc#modules#disabled          = [ "command"
                                       \ , "bibliographies"
                                       \ , "completion"
                                       \ , "menu"
                                       \ , "autocomplete" ]
" Enable pandoc for markdown files
let g:pandoc#filetypes#handled         = [ "pandoc", "markdown" ]
let g:pandoc#filetypes#pandoc_markdown = 1
let g:pandoc#formatting#mode           = 'hA'
let g:pandoc#formatting#textwidth      = 80
let g:pandoc#spell#enabled             = 0
let g:pandoc#folding#fold_yaml         = 1
let g:pandoc#folding#fastfolds         = 1
let g:pandoc#keyboard#use_default_mappings = 1
let g:pandoc#keyboard#sections#header_style = 'a'
let g:pandoc#hypertext#create_if_no_alternates_exists = 1
au Filetype pandoc set colorcolumn=80


"  ___ _ _   _____   __  __
" | _ |_) |_|_   _|__\ \/ /
" | _ \ | '_ \| |/ -_)>  < 
" |___/_|_.__/|_|\___/_/\_\
"                          
" Use fzf-bibtex to easily insert references to papers
" In normal mode, use <leader>c to cite, and <leader>m to insert a pretty
" printed display of the citation. In insert mode, use @@ to insert a
" citation.
" Taken from https://github.com/msprev/fzf-bibtex README
function! s:bibtex_cite_sink(lines)
    let r=system("bibtex-cite ", a:lines)
    execute ':normal! a' . r
endfunction

function! s:bibtex_markdown_sink(lines)
    let r=system("bibtex-markdown ", a:lines)
    execute ':normal! a' . r
endfunction

nnoremap <silent> <leader>c :call fzf#run({
                        \ 'source': 'bibtex-ls',
                        \ 'sink*': function('<sid>bibtex_cite_sink'),
                        \ 'up': '40%',
                        \ 'options': '--ansi --layout=reverse-list --multi --prompt "Cite> "'})<CR>

nnoremap <silent> <leader>m :call fzf#run({
                        \ 'source': 'bibtex-ls',
                        \ 'sink*': function('<sid>bibtex_markdown_sink'),
                        \ 'up': '40%',
                        \ 'options': '--ansi --layout=reverse-list --multi --prompt "Markdown> "'})<CR>

function! s:bibtex_cite_sink_insert(lines)
    let r=system("bibtex-cite ", a:lines)
    execute ':normal! a' . r
    call feedkeys('a', 'n')
endfunction

inoremap <silent> @@ <c-g>u<c-o>:call fzf#run({
                        \ 'source': 'bibtex-ls',
                        \ 'sink*': function('<sid>bibtex_cite_sink_insert'),
                        \ 'up': '40%',
                        \ 'options': '--ansi --layout=reverse-list --multi --prompt "Cite> "'})<CR>


"  _____     _    _       __  __         _     
" |_   _|_ _| |__| |___  |  \/  |___  __| |___ 
"   | |/ _` | '_ \ / -_) | |\/| / _ \/ _` / -_)
"   |_|\__,_|_.__/_\___| |_|  |_\___/\__,_\___|
"                                              
" Use pandoc grid table format
let g:table_mode_corner_corner='+'
let g:table_mode_header_fillchar='='
" Compatibility with vim-pandoc
au User TableModeEnabled call pandoc#formatting#DisableAutoformat()
au User TableModeDisabled call pandoc#formatting#EnableAutoformat()

